package geocodexyz

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strconv"

	"github.com/go-resty/resty/v2"
)

var httpClient *resty.Client

// Note: these have been autogenerated and not been validated yet so may (will) change.

// ReverseLocationLookupResult is the main return for a location look up. Not all fields are always returned.
type ReverseLocationLookupResult struct {
	Statename string `json:"statename"`
	Distance  string `json:"distance"`
	Elevation string `json:"elevation"`
	Osmtags   struct {
		Wikipedia  string `json:"wikipedia"`
		Wikidata   string `json:"wikidata"`
		Place      string `json:"place"`
		Name       string `json:"name"`
		LandArea   string `json:"land_area"`
		AdminLevel string `json:"admin_level"`
		Boundary   string `json:"boundary"`
		Type       string `json:"type"`
	} `json:"osmtags"`
	State     string `json:"state"`
	Latt      string `json:"latt"`
	City      string `json:"city"`
	Prov      string `json:"prov"`
	Geocode   string `json:"geocode"`
	Geonumber string `json:"geonumber"`
	Country   string `json:"country"`
	Stnumber  string `json:"stnumber"`
	Staddress string `json:"staddress"`
	Inlatt    string `json:"inlatt"`
	Alt       struct {
		Loc []struct {
			Staddress string `json:"staddress"`
			Stnumber  string `json:"stnumber"`
			Postal    string `json:"postal"`
			Latt      string `json:"latt"`
			City      string `json:"city"`
			Prov      string `json:"prov"`
			Longt     string `json:"longt"`
			Class     struct {
			} `json:"class"`
			Dist string `json:"dist"`
		} `json:"loc"`
	} `json:"alt"`
	Timezone         string `json:"timezone"`
	Region           string `json:"region"`
	Postal           string `json:"postal"`
	Longt            string `json:"longt"`
	RemainingCredits struct {
	} `json:"remaining_credits"`
	Confidence string `json:"confidence"`
	Inlongt    string `json:"inlongt"`
	Class      struct {
	} `json:"class"`
	Adminareas struct {
		Admin6 struct {
			Wikipedia        string `json:"wikipedia"`
			Wikidata         string `json:"wikidata"`
			Population       string `json:"population"`
			Name             string `json:"name"`
			SourcePopulation string `json:"source_population"`
			NistStateFips    string `json:"nist_state_fips"`
			AdminLevel       string `json:"admin_level"`
			NistFipsCode     string `json:"nist_fips_code"`
			Level            string `json:"level"`
			Boundary         string `json:"boundary"`
			Type             string `json:"type"`
			BorderType       string `json:"border_type"`
		} `json:"admin6"`
		Admin8 struct {
			Wikipedia  string `json:"wikipedia"`
			Wikidata   string `json:"wikidata"`
			Place      string `json:"place"`
			Name       string `json:"name"`
			LandArea   string `json:"land_area"`
			AdminLevel string `json:"admin_level"`
			Level      string `json:"level"`
			Boundary   string `json:"boundary"`
			Type       string `json:"type"`
		} `json:"admin8"`
	} `json:"adminareas"`
	Altgeocode string `json:"altgeocode"`
}

// LocationLookupResult is a successful lookup for a location passed in, such as "123 Main Street, Salem, NH"
type LocationLookupResult struct {
	Standard struct {
		Stnumber string `json:"stnumber"`
		Addresst string `json:"addresst"`
		Postal   struct {
		} `json:"postal"`
		Region string `json:"region"`
		Zip    struct {
		} `json:"zip"`
		Prov        string `json:"prov"`
		City        string `json:"city"`
		Countryname string `json:"countryname"`
		Confidence  string `json:"confidence"`
	} `json:"standard"`
	Longt string `json:"longt"`
	Alt   struct {
	} `json:"alt"`
	Elevation struct {
	} `json:"elevation"`
	Latt string `json:"latt"`
}

// APIError holds information about the rate limit or location miss errors
type APIError struct {
	Description string `json:"description"`
	Code        string `json:"code"`
	Requests    int    `json:"requests"`
}

func (input *APIError) Error() string {
	return input.Code
}

// makeCall actually calls the target API. Unfortunately, they return error codes as HTTP 200, with the shapes of the
// json returns changing depending on the error, so this method gets pretty messy with some of the paths.
func makeCall(params ReverseLookupRequest) ([]byte, *APIError, error) {
	if httpClient == nil {
		httpClient = resty.New()
	}

	b := []byte{}

	request := httpClient.R()
	data := params.toMap()
	data["auth"] = config.APIKey
	if config.SendMethod == http.MethodGet {
		request.SetQueryParams(data)
	} else if config.SendMethod == http.MethodPost {
		request.SetFormData(data)
	} else {
		// unsupported
		return b, nil, errors.New("method must be GET or POST")
	}
	response, err := request.Execute(config.SendMethod, "https://geocode.xyz")
	if err != nil {
		return b, nil, err
	}
	code := response.StatusCode()
	b = response.Body()
	if code != http.StatusOK && code != http.StatusForbidden {
		// unknown error
		return b, nil, fmt.Errorf("unknown status code: %d", code)
	}

	// since they return errors with an HTTP 200, it's not as simple to decode
	// so first we will put it in a map[string]interface{} to determine if there
	// is an error field
	resultMap := map[string]interface{}{}
	err = json.Unmarshal(b, &resultMap)
	if err != nil {
		return b, nil, err
	}
	if _, ok := resultMap["error"]; ok {
		// it is an error, so we can return the error
		errorMap, ok := resultMap["error"].(map[string]string)
		if !ok {
			return b, nil, errors.New("could not convert the error")
		}
		apiError := &APIError{
			Code:        errorMap["code"],
			Description: errorMap["description"],
		}
		if errorMap["code"] == "006" {
			// it has a requests field stored as a string
			apiError.Requests, _ = strconv.Atoi(errorMap["requests"])
		}
		return b, apiError, apiError
	}

	return b, nil, nil
}
